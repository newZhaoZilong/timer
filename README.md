#一个有自动校准功能的定时器#

倒计时是比较常用的工具，最近正好可以写一个定时器对象练手

##倒计时流程##
###工具方法###

倒计时首先有一些工具的方法，一般是输入一个倒计时数字，然后将其转为一串类似'00：00：10'这种形式的字符串，所以我写了一个方法如下：

      function durationToStr(dt, intervalStr = ' ') {
        var hour = parseInt(dt / 3600);
        var min = parseInt((dt / 60 - hour * 60));
        var s = parseInt(dt - hour * 3600 - min * 60);
        return [hour, min, s].map((v) => {
          v = v.toString();
          return v[1] ? v : '0' + v;
        }).join(intervalStr);
      }
      
思路是先将数字除以3600获取当前的小时数，然后减去小时占用的秒数，剩下的数除以60获取当前的分钟数，然后减去小时和分钟占用的秒数，获取
当前的秒数，然后放到数组里，通过map遍历的将数字修改成对应的字符串然后通过join方法拼接成最终需要的'00:00:30'这种字符串

###明确核心思想###

首先定时器的核心方法我先确定的有两个，一个是构造函数，因为创建对象的时候需要传入一些重要参数，考虑传入一个initObj对象，对象里有很多属性，都是Timer对象需要的初始化参数，如倒计时时间，其实核心的参数就这一个，
然后定义一个核心方法，start，最终的效果是构造函数new一个Timer对象，传入一个参数对象，之后就可以使用这个对象的start
方法开始倒计时，目标其实就是这样简单，考虑到对外输出，就必须提供一个回掉函数，也当作参数在初始化的时候传入
构造方法大概是这样的：这是es6的写法

      constructor(initObj = {}) {
        this.interval = initObj.interval || 1000; //间隔时间,
        this.duration = initObj.duration || 10; //倒计时时间，默认10s
        this.callBack = initObj.callBack; //回掉函数，用于执行代码
        this.complete = initObj.complete; //倒计时结束后执行
        this.joinStr = initObj.joinStr; //倒计时数字之间的字符串
      }  

###执行流程###
执行流程主要是放在start方法里

1. 首先将30这个数字通过上面的工具方法将数字转为倒计时字符串

2. 调用回掉函数，将倒计时字符串作为函数参数传进去，这样就将数据提供了出去

3. 根据间隔时间计算出定时器延时时间，一般为1秒，设置相应的定时器

4. 等到1秒结束后，执行定时器的回掉函数，回掉函数里将计时数字减去1，变成29，重新执行start方法，重复第一步，这时数字变为29，

5. 在第二步和第三步之间判断计时数字是否为0，如果为0，执行complete函数，结束

这里其实有几个疑问，为什么先执行第二步而不是先执行第四步，因为我想的是，如果是30秒，首先应该立刻把00:00:30显示到界面上，所以要立刻把数据提供出去，
再执行定时器，如果先执行定时器，那么数据在1秒后才会显示

那又为什么是定时器结束后秒数减一而不是第三步在设置定时器之前就减一，感觉一样啊，这里是因为有时可能需要暂停计时，这个时候一般是清除定时器，比如这个时候
已经显示是00:00:15了，暂停清除了定时器，如果在定时器之前秒数已经减一了，那么秒数是14，下次调用start方法重新开始，因为秒数是14，会马上提供出00:00:14，视觉效果上就是
00:00:15会马上变为00:00:14,这样不太合理，按常理来讲,应该是1秒后才变化，所以应该**在定时器的回掉函数执行的时候将秒数减一，这样能保证清除定时器后实际的秒数和显示的秒数同步**



###执行流程的修改###

这里其实还是有很多问题的，实际的问题就是setTimeout的时间是1秒后执行,那么如果递归的执行setTimeout的话，倒计时的平均间隔时间应该会超出1秒，因为setTimeout只是1秒后执行,并不包含代码执行的时间,所以就有偏差，而且如果是小程序的话，一般数据是通过this.setData将数据渲染到视图层的，有时渲染的快，有时渲染的慢，界面上很容易出现秒数忽快忽慢的情况

所以需要自动校正偏差时间，方法是设置定时器的时候先记录一下当前时间，然后减去上次时间，如果当前和上次的时间差大于一秒，那么说上次走慢了，算出走慢了多少毫秒（偏差时间），然后通过间隔时间，就是1秒减去偏差时间，获取到这次定时器应该延时的时间值，这样的话，其实就是添加了一个自动校正功能，每次设置定时器的时候都在校正，这样平均误差基本为0，已经很好了

	        //获取当前时间的毫秒数
        var currentTime = Date.now();
        var offsetTime = this.lastTime ? (currentTime - this.lastTime - this.interval) : 0;
        this.lastTime = currentTime;
        var correctTime = (this.interval - offsetTime > 0) ? (this.interval - offsetTime) : 0;

        console.log(`当前时间:${currentTime} 偏移时间:${offsetTime} 校准后的延时时间${correctTime}`);



##定时器总结##

这个定时器唯一的亮点就是增加了一个自动校准的功能，这个思想就是**每次获取系统时间，减去上次时间，再减去间隔时间获取偏差值，然后通过间隔时间减去偏差值获取正确的定时器的延时时间，**，

之后我写了一个stop函数目的是暂停倒计时，然后再调用start方法，倒计时又重新启动，暂停的话，因为start内部执行递归（就是调用自身）是放在定时器的回调函数里的，所以想要暂停定时器就要避免递归，

需要在两个方面同时避免

1. 避免创建定时器

2. 清除即将执行的定时器

对于第一条要再定时器前面加个条件判断，暂停的时候设置为false，对于第二条通过clearTimeout立刻清除将要执行的定时器

##定时器原理##
除了主 JavaScript 执行进程外，还有一个需要在进程下一次空闲时执行的代码队列。随着页面在其
生命周期中的推移，代码会按照执行顺序添加入队列。

定时器对队列的工作方式是，当特定时间过去后将代码插入。注意，给队列添加代码并不意味着对
它立刻执行，而只能表示它会尽快执行。设定一个 150ms 后执行的定时器不代表到了 150ms 代码就立刻
执行，它表示代码会在 150ms 后被加入到队列中。如果在这个时间点上，队列中没有其他东西，那么这
段代码就会被执行，表面上看上去好像代码就在精确指定的时间点上执行了。其他情况下，代码可能明
显地等待更长时间才执行。

**关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不
是何时实际执行代码。**

小程序定时器源码 [https://github.com/newZhaoZilong/timer](https://github.com/newZhaoZilong/timer)
